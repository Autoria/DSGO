# 简单排序
排序是个古老的问题，虽说其核心操作只有比较和腾挪，可是玩法也有很多种。鉴于要排序的数据经常以数组的形式存在，本章接下来对其进行一番探讨。

## 冒泡排序
冒泡排序以腾挪为切入点考虑排序问题，其思路非常简单：尽量往合适的位置挪，挪一步是一步，到挪不动的时候就好了。现实中，我们排队出操经常就是这么干的：看看旁边的小伙伴，不合适就换个位置，个子高的自然就到后面去了。鱼缸里的气泡往上浮，石头往下沉，也是这种感觉。
```go
	func BubleSort(list []int) {
		for i := 0; i < len(list)-1; i++ {
			for j := len(list) - 1; j > i; j-- {
				if list[j] < list[j-1] {
					list[j], list[j-1] = list[j-1], list[j]
				} //不合适就换位
			}
		}
	}
```
冒泡排序看起来很不错，但其实犯了"目光短浅"的大忌，最后竟落得比较次数和挪移次数都到了O(N<sup>2</sup>)。

## 选择排序
选择排序则是以比较为切入点考虑排序问题的，其思路也很简单：每次从剩下的中选出最合适的一个，最终排成一列。
```go
	func SelectSort(list []int) {
		for i := 0; i < len(list)-1; i++ {
			var pos = i
			for j := i + 1; j < len(list); j++ {
				if list[j] < list[pos] {
					pos = j
				} //找到最佳
			}
			list[pos], list[i] = list[i], list[pos]
		}
	}
```
在一番精挑细选之后，选择排序把挪移操作限制在O(N)，可是比较操作妥妥地到了O(N<sup>2</sup>)。

## 插入排序
插入排序和选择排序一样，把数据分作有序和无序两部分，不同的是选择排序是留了坑找人填，而插入排序是先来人后找坑。
```go
	func InsertSort(list []int) {
		for i := 1; i < len(list); i++ {
			var start, end = 0, i
			var key = list[i]
			for start < end {
				var mid = (start + end) / 2
				if key < list[mid] {
					end = mid
				} else {
					start = mid + 1
				}
			}
			for j := i; j > start; j-- {
				list[j] = list[j-1]
			} //腾个空
			list[start] = key //挪进来
		}
	}
```
前面两种其实都没有很好地利用到数组可随机访问的优势，而插入排序借助先前所说的二分查找大法，可以让比较次数降到O(NlogN)，遗憾的是腾挪次数最坏情况下还是O(N<sup>2</sup>)。不过，平均的腾挪次数只有最坏情况的一半，在实际应用中插入排序要比选择排序要快一倍左右。

## 小结

这三种排序算法很好地反映了关于排序的三种重要思路，后面的归并排序、快速排序以及堆排序将会把它们发扬光大。

---
[目录](../index.md)　[上一节](01.md)　[下一节](01-B.md)