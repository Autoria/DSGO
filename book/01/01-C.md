# 快速排序

归并排序其实已经将比较操作优化到极致了（极致就是O(NlogN)，兴趣的读者可以自行补完），但挪移操作还有改进空间。或许你还记得选择排序那霸气的O(N)，不过最先关注挪移操作的可是落魄的冒泡排序哦。而在本节，它的后继者——快速排序要来上演一番逆袭……

## 谁与争锋
敢叫“快速”排序，怎能不快？在分析其原理之前，我们先来50万的随机数列：

	BubleSort:	8m5.2627555s	--被虐成狗了
	SelectSort:	1m39.8587116s	--算有个人样
	InsertSort:	52.8680238s		--再打扮打扮
	HeapSort:	74.0043ms		--快
	MergeSort:	52.0029ms		--更快
	QuickSort:	48.0028ms		--谁与争锋！

从表现上看，新玩家将它们的老祖宗甩了几条街，其中快速排序果然是最快的。虽然快速排序不至于快到没有朋友，不过比开了挂的归并排序竟然还要快一成左右，也是蛮拼的。

## 分层沉淀
那么“快”是怎么做到的呢？没错，就是从冒泡排序那里继承而来的浮沉之道。只是一个一个挪效率太低，大自然可不这么干，君看把油和水搅到一起，静放一会儿便会分成两层。
```go
	func partition(list []int) int {
		var barrier = list[0]
		var a, b = 1, size-1
		for {
			for list[a] < barrier { a++ } //不挪才是
			for list[b] > barrier { b-- } //快的关键
			if a >= b { break }
			list[a], list[b] = list[b], list[a] //不合适就换位
			a++; b--
		}
		list[0], list[b] = list[b], barrier
		return b
	}
```
分层与归并虽然路线相左，但有个共同点：只需一次遍历就能完成。在这一次遍历中归并对每一个元素都进行了挪移，而上述分层过程仅挪移了某些元素，这是快速排序能比归并排序更快的根本原因。

只分一次显然是不够的，还是老办法：一分二，二分四……
```go
	func QuickSort(list []int, life uint) {
		if len(list) < sz_limit {
			InsertSort(list)
		} else {
			var knot = partition(list)
			QuickSort(list[0:knot])
			QuickSort(list[knot+1:size])
		}
	}
```

## 软肋与补救
自然沉淀的分界面取决于物理常数，而我们对数列排序时分界面要自己选。怎么选是个大问题，选得不好容易重蹈冒泡排序的覆辙，这也正也是快速排序的软肋所在。

既然不知道怎么选，那么大可以先随机选几个，再剔掉最烂的。虽说也是治标不治本，不过好歹比固定选某个强。
```go
var magic = ^uint(0)
func partition(list []int) int {
	var size = len(list)					//不少于3
	var x, y = int(magic % uint(size-1)), int(magic % uint(size-2))
	magic = magic*1103515245 + 12345		//伪随机数步进
	var a, b = 1 + x, 1 + (1+x+y)%(size-1)	//a != b
	
	var barrier = list[0]					//三点取中法
	if list[0] > list[a] {
		if list[a] > list[b] {
			barrier, list[a] = list[a], list[0]
		} else {
			if list[0] > list[b] {
				barrier, list[b] = list[b], list[0]
			}
		}
	} else {
		if list[b] > list[0] {
			if list[a] > list[b] {
				barrier, list[b] = list[b], list[0]
			} else {
				barrier, list[a] = list[a], list[0]
			}
		}
	}
	
	//后面你懂的...
}
```

## 内省排序
如上文所述，快速排序的平均复杂度和归并排序是一个级别的，但最坏情况下却在向冒泡排序靠拢。快速排序的神经刀体质看了是没有办法彻底解决，不过我们还可以祭出打怪兽的必杀技——召唤小伙伴！
```go
	func IntroSort(list []int) {
		var life = uint(12)
		for size := len(list); size != 0; size /= 2 {
			life++
		} //充满能量
		doIntroSort(list, life)
	}
	func doIntroSort(list []int, life uint) {
		if len(list) < sz_limit {
			InsertSort(list)
		} else if life == 0 {	//能量用光了不要死扛
			HeapSort(list) 		//果断召唤小伙伴（也可以召唤MergeSort）
		} else {
			var knot = partition(list)
			doIntroSort(list[0:knot], life-1)
			doIntroSort(list[knot+1:size], life-1)
		}
	}
```
这种流氓打法结合了三大排序思想（召唤堆排序的话），被称之为内省排序。  
至于什么是堆排序，我们到第六章再讨论，心急的读者可以点 [传送门](../06/06-A.md) 先睹为快。

---
[目录](../index.md)　[上一节](01-B.md)　[下一节](01.md)
