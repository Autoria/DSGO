# 链表的排序
有些时候我们也希望得到有序链表，那么还得排序。

# 归并排序
链表不能象数组那样随机访问，分割要多费些周折。不过链表的归并并不需要额外空间，链表归并排序的空间复杂度只有(1)。
```go
	func doMergeSort(head *Node) (first *Node, last *Node) {
		first, last = head, FakeHead(&first)
		var size = 0
		for ; head != nil; size += 2 {						//先探规模
			if head.Next == nil {
				last = head
				size++
				break
			}
			var node0, node1 = head, head.Next
			head = node1.Next
			if node0.Val > node1.Val {
				last.Next, node1.Next, node0.Next = node1, node0, head
				last = node0
			} else {
				last = node1
			}
		}

		for step := 2; step < size; step *= 2 {
			head, last = first, FakeHead(&first)
			for head != nil {
				var left, right, node *Node
				left, head = head, cutPeice(head, step)		//切至多step大小的一段
				right, head = head, cutPeice(head, step)	//切第二段

				last.Next, node = merge(left, right)		//归并之
				last, node.Next = node, head
			}
		}
		return first, last
	}
```
由于先分割后归并，归并排序在每轮处理中需要遍历两次链表，因此在速度上稍逊于快速排序。

# 内省排序
随机三点取中法在链表中难以实现，链表上的快速排序更容易陷入最坏情况，因此使用内省排序更合理。
```go
	func doIntroSort(head *Node, life uint) (first *Node, last *Node) {
		if head.Next == nil { //head != nil
			return head, head
		}
		var node = head.Next
		if node.Next == nil {
			if head.Val > node.Val {
				node.Next, head.Next = head, nil
				return node, head
			}
			return head, node
		}

		if life == 0 {
			first, last = doMergeSort(head)					//召唤小伙伴
		} else {
			var left, center, right, _ = partition(head)
			first, node = doIntroSort(left, life-1)
			node.Next = center
			center.Next, last = doIntroSort(right, life-1)
		}
		return first, last
	}
```

---
[目录](../index.md)　[上一节](02.md)　[下一节](02-B.md)
