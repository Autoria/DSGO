# Hash表
 1. [开链式Hash表](04-A.md)
 2. [多路Hash表](04-B.md)
 3. [完全Hash](04-C.md)
 
___
在前面的章节中，我们见过一些O(logN)级的查找算法，而本章我们讨论O(1)级的办法。

## Hash函数
![](../images/Hash.png)
　　实现极速查找的奥秘在于把目标对象映射到一个数组中去，而每个对象在数组中的位置，则是根据对象的内容计算出来的。这种计算索引的函数称为Hash函数。

## Hash冲突
　　Hash函数实现的是由多到少的映射，难免有时会把不同的对象映射到同一个位置，此时冲突就发生了。怎么解决这种冲突是本章的核心议题。

在展开讨论之前，我们对经典的几种字符串Hash函数做一个小实验：

| Hash函数 |最大冲突|无冲突|两项冲突|三项冲突|四项冲突|五项冲突|六项冲突|
| :------- |:---:|----:|----:|----:|----:|----:|----:|
| BKDRhash | 6项 | 16619 | 10410 | 3195 | 732 | 140 |  6 |
| SDBMhash | 6项 | 16405 | 10684 | 3237 | 640 | 130 |  6 |
| DJBhash  | 6项 | 16473 | 10536 | 3267 | 740 |  80 |  6 |
| FNVhash  | 5项 | 16583 | 10368 | 3342 | 704 | 105 |  0 |
| RShash   | 6项 | 16527 | 10502 | 3231 | 704 | 120 | 18 |
| JShash   | 6项 | 16404 | 10494 | 3378 | 664 | 150 | 12 |
| APhash   | 6项 | 16613 | 10492 | 3252 | 636 |  85 | 24 |

我们把31102个字符串映射到49157个位置时，其中近一半元素遇到了冲突，可见Hash冲突是不得不关注的问题。

---
[返回目录](../index.md)
