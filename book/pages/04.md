# Hash表
 1. [开链式Hash表](04-A.md)
 2. [多路Hash表](04-B.md)
 3. [完全Hash](04-C.md)
 
___
在前面的章节中，我们见到了一些O(logN)时间的查找算法，而本章所讨论的数据结构将能把查找时间降至O(1)。

## Hash函数
![](../images/Hash.png)
　　实现极速查找的奥秘在于把目标对象映射到一个数组中去，而每个对象在数组中的位置根据对象自身计算出来的。根据索引从数组中寻找元素可谓不费吹灰之力，剩下的问题就是索引的计算。我们称这种计算索引的函数为Hash函数。

## Hash冲突
　　hash函数的的本质实现的是有多到少的映射，难免有时会把不同的对象映射到同一个位置，此时冲突就发生了。怎么解决这种冲突是本章的核心议题。不过，在展开讨论之前，我们对经典的几种字符串Hash函数做一个小实验。
 
	Bible.txt [31102/49157]
	BKDRhash: <6> [16619 10410 3195 732 140  6]
	SDBMhash: <6> [16405 10684 3237 640 130  6]
	DJBhash:  <6> [16473 10536 3267 740  80  6]
	DJB2hash: <7> [16448 10470 3312 708 145 19]
	FNVhash:  <5> [16583 10368 3342 704 105  0]
	RShash:   <6> [16527 10502 3231 704 120 18]
	JShash:   <6> [16404 10494 3378 664 150 12]
	APhash:   <6> [16613 10492 3252 636  85 24]

　　以上显示了每个函数把31102个字符串映射到49157个位置时，最大冲突数，无冲突元素个数，二元、三元、四元、五元、六元及以上冲突元素个数。其中，近一半元素遇到了冲突，可见Hash冲突还是不得不关注的问题。

---
[返回目录](../index.md)
