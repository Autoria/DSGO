# 基数树
![](../images/RadixTree.png)

基数树就是一种简单有效的分级索引结构，每层索引为键值的一个片段。
```go
	type node struct {
		kids [kidsLimit]*node
	}
	func cut(key uint, i uint) uint {
		return (key >> ((lenOfUint - step) - i*step)) & mask
	}
```
基数的操作比较简单，删除时注意级联处理就好。
```go
	func (tr *Tree) Insert(key uint, ptr unsafe.Pointer) bool {
		var root = &tr.root
		for i := uint(0); i < depth-1; i++ {
			var idx = cut(key, i)
			if root.kids[idx] == nil {
				root.kids[idx] = new(node)
			}
			root = root.kids[idx]
		}
		var idx = key & mask
		if root.kids[idx] != nil { return false }
		root.kids[idx] = (*node)(ptr)
		return true
	}
	
	func (tr *Tree) Remove(key uint) bool {
		var path [depth]*node
		path[0] = &tr.root
		for i := uint(0); i < depth-1; i++ {
			path[i+1] = path[i].kids[cut(key, i)]
			if path[i+1] == nil { return false }
		}
		var idx = key & mask
		if path[depth-1].kids[idx] == nil { return false }
		path[depth-1].kids[idx] = nil
		for i := depth - 1; i != 0; i-- {
			var j = uint(0)
			for j < kidsLimit && path[i].kids[j] == nil { j++ }
			if j == kidsLimit { //全空
				path[i-1].kids[cut(key, i-1)] = nil
			}
		}
		return true
	}
```

## 字典树
![](../images/Trie.png)

　　字典树又称前缀树，是一种针对序列的索引结构。字典树的基本原理和基数树一样，不过由于序列长度并不固定，情况要更加复杂一些。另外
```go
	type node struct {
		key  [capacity]byte
		cnt  uint8
		ref  uint16
		kids []*node
	}
```

```go
	func (root *node) Insert(data []byte) {
		if len(data) == 0 { return }
		var mk = uint8(0)
		for idx := 0; idx < len(data); idx++ {
			if mk == root.cnt { //下探
				var spot = root.searchKid(data[idx])
				if spot == len(root.kids) || root.kids[spot].key[0] != data[idx] {
					root.kids = append(root.kids, nil)
					for i := len(root.kids) - 1; i > spot; i-- {
						root.kids[i] = root.kids[i-1]
					}
					root.kids[spot] = createTail(data[idx:])
					return
				}
				root = root.kids[spot]
				mk = 1
			} else {
				if root.key[mk] != data[idx] {
					root.split(mk)
					root.kids = append(root.kids, createTail(data[idx:]))
					if root.kids[0].key[0] > root.kids[1].key[0] {
						root.kids[0], root.kids[1] = root.kids[1], root.kids[0]
					}
					return
				}
				mk++
			}
		}
		if mk != root.cnt { root.split(mk) }
		root.ref++
	}
```

```go
	func (root *node) Remove(data []byte, all bool) {
		if len(data) == 0 { return }
		var knot, branch = (*node)(nil), 0 //记录独苗分支节点
		var mk = uint8(0)
		for idx := 0; idx < len(data); idx++ {
			if mk == root.cnt { //下探
				var spot = root.searchKid(data[idx])
				if spot == len(root.kids) ||
					root.kids[spot].key[0] != data[idx] { return }
				if root.ref != 0 || len(root.kids) > 1 {
					knot, branch = root, spot
				}
				root = root.kids[spot]
				mk = 1
			} else {
				if root.key[mk] != data[idx] { return }
				mk++
			}
		}
		if mk != root.cnt || root.ref == 0 { return }
		if all { root.ref = 0
		} else { root.ref-- }
	
		if root.ref == 0 && len(root.kids) == 0 {
			for i := branch + 1; i < len(knot.kids); i++ {
				knot.kids[i-1] = knot.kids[i]
			} //删除独苗
			knot.kids = knot.kids[:len(knot.kids)-1]
		}
	}
```

```go
	func (root *node) Search(data []byte) uint16 {
		var mk = uint8(0)
		for idx := 0; idx < len(data); idx++ {
			if mk == root.cnt { //下探
				if len(root.kids) == 1 && root.ref == 0 && root.cnt < capacity {
					var kid = root.kids[0]
					if root.cnt+kid.cnt > capacity { //半缩
						var j = uint8(0)
						for i := root.cnt; i < capacity; i++ {
							root.key[i] = kid.key[j]
							j++
						}
						root.cnt = capacity
						var i = uint8(0)
						for ; j < kid.cnt; j++ {
							kid.key[i] = kid.key[j]
							i++
						}
						kid.cnt = i
					} else { //全缩
						for i := uint8(0); i < kid.cnt; i++ {
							root.key[root.cnt] = kid.key[i]
							root.cnt++
						}
						root.ref, root.kids = kid.ref, kid.kids
					}
				} else { //单纯下探
					var spot = root.searchKid(data[idx])
					if spot == len(root.kids) ||
						root.kids[spot].key[0] != data[idx] { return 0 }
					root = root.kids[spot]
					mk = 1
					continue
				}
			}
			if data[idx] != root.key[mk] { return 0 }
			mk++
		}
		if mk != root.cnt { return 0 }
		return root.ref
	}
```

---
[目录](../index.md)　[上一节](05-D.md)　[下一节](05.md)