# 二叉堆

## 浮沉
```go
	func (hp *Heap) adjustDown(spot int) {
		var size = len(hp.core)
		var key = hp.core[spot]
		var left, right = spot*2 + 1, spot*2 + 2
		for right < size {
			var kid = 0
			if hp.core[left] < hp.core[right] {
				kid = left
			} else {
				kid = right
			}
			if key <= hp.core[kid] { goto Label_OVER }
			
			hp.core[spot] = hp.core[kid]
			spot, left, right = kid, kid*2+1, kid*2+2
		}
		if right == size && key > hp.core[left] {
			hp.core[spot], hp.core[left] = hp.core[left], key
			return
		}
	Label_OVER:
		hp.core[spot] = key
	}
	
	func (hp *Heap) adjustUp(spot int) {
		var key = hp.core[spot]
		for spot > 0 {
			var parent = (spot - 1) / 2
			if hp.core[parent] <= key { break }
			
			hp.core[spot], spot = hp.core[parent], parent
		}
		hp.core[spot] = key
	}
```

## 创建
```go
	func (hp *Heap) Build(list []int) {
		var size = len(list)
		hp.core = list
		for idx := size/2 - 1; idx >= 0; idx-- {
			hp.adjustDown(idx)
		}
	}
```

## 压入&弹出
```go
	func (hp *Heap) Push(key int) {
		var place = len(hp.core)
		hp.core = append(hp.core, key)
		hp.adjustUp(place)
	}
	
	func (hp *Heap) Pop() (key int, fail bool) {
		var size = hp.Size()
		if size == 0 { return 0, true }

		key = hp.core[0]
		if size == 1 {
			hp.core = hp.core[:0]
		} else {
			hp.core[0] = hp.core[size-1]
			hp.core = hp.core[:size-1]
			hp.adjustDown(0)
		}
		return key, false
	}
```

---
[目录](../index.md)　[上一节](06.md)　[下一节](06-B.md)