# SPFA算法
Dijkstra算法最先暴露的问题还不是高分低能，而是不支持负权值边。本节所讨论的算法就是要解决此问题。

## Floyd-Warshall算法
　　重复经过负权值边可以获益，Dijkstra算法中的一选定终身不能满足这里的要求。为解决此问题，我们可以选择浪淘沙式的迭代更新。假定点之间最短距离存在（没有负回路），O(V<sup>3</sup>)的时间内就能得到任意两点间的最短距离。
```go
	func FloydWarshall(matrix [][]int) {
		var size = len(matrix)
		for k := 0; k < size; k++ {
			for i := 0; i < size; i++ {
				for j := 0; j < size; j++ {
					if matrix[i][k] != MAX_DIST && matrix[k][j] != MAX_DIST {
						var distance = matrix[i][k] + matrix[k][j]
						if distance < matrix[i][j] {
							matrix[i][j] = distance
	}	}	}	}	}	}
```

## 精确打击
　　Floyd-Warshall算法的缺点很明显，进行了大量不必要的试探性修改。从Dijkstra算法，我们可以看到一个事实：某个点只有与发生变化的点相邻才可能发生变化。SPFA算法使用一个队列将变化的点记录起来，实施精确打击。
```go
	func SPFA(roads [][]Path, start int) (dists []int, fail bool) {
		//...
		var q = newQueue(size)									//队列
		dists = make([]int, size)								//记录到各点的最短距离
		var cnts = make([]int, size)							//绝对值记录入队次数
		for i := 0; i < size; i++ {
			dists[i], cnts[i] = MAX_DIST, 0						//初始皆不可达
		}

		q.push(start)
		dists[start], cnts[start] = 0, -1						//负值表示在队列中
		for !q.isEmpty() {
			var current = q.pop()
			cnts[current] = -cnts[current]
			for _, path := range roads[current] {
				var distance = dists[current] + path.Dist
				var peer = path.Next
				if distance < dists[peer] {
					dists[peer] = distance
					if cnts[peer] >= 0 {						//不在队列中
						q.push(peer)
						cnts[peer]++
						if cnts[peer] > size {					//入队次数超标
							return []int{}, true				//必定是有负回路
						}
						cnts[peer] = -cnts[peer] //入队
		}	}	}	}
		return dists, false
	}
```

## 性能分析
　　SPFA算法的时间开销，取决于点进入队列的次数。点的每一次入队将使与其相连的边被遍历，最坏情况下，边都会被遍历(V-1)次，耗时达O(EV)级。但是，在我们上一节也看到了，实际使用中，该算法用时远远低于理论上限。

---
[目录](../index.md)　[上一节](07-C.md)　[下一节](07-E.md)
